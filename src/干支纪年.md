# 定义

干支纪年是一种周期计时的方法.

年以公转作为一个单位,六十年一个周期.

月以 15 度公转角作为一个单位,十二月一个周期.

日以自传作为一个单位,六十日一个周期.

时以时辰(2 小时)作为一个单位,十二小时一个周期.

干支纪年不置闰,强绑定星轨和天体运动,人为的规定比较小.

干支纪年不是农历,干支月和月亮盈亏周期没有直接联系.

# 干支

```typescript
enum 阳干 {
  甲 = "甲",
  丙 = "丙",
  戊 = "戊",
  庚 = "庚",
  壬 = "壬",
}

enum 阴干 {
  乙 = "乙",
  丁 = "丁",
  己 = "己",
  辛 = "辛",
  癸 = "癸",
}

enum 阳支 {
  子 = "子",
  辰 = "辰",
  寅 = "寅",
  午 = "午",
  戌 = "戌",
  申 = "申",
}

enum 阴支 {
  丑 = "丑",
  卯 = "卯",
  巳 = "巳",
  未 = "未",
  酉 = "酉",
  亥 = "亥",
}

const 天干 = { ...阳干, ...阴干 } as const;
const 地支 = { ...阳支, ...阴支 } as const;

export type 干支 = `${阳干}${阳支}` | `${阴干}${阴支}`;
```

根据干支的组合方式,可以推出周期`阳干*阳支+阴干*阴支`为 60.

对天干按 10 取余,地支按 12 取余,可以得到`干支排列表`

```typescript
export const 干支排列表 = 一至六十序数.map(
  (i) => `${天干序数映射[i % 10 || 10]}${地支序数映射[i % 12 || 12]}` as 干支
);

export const 干支列表: React.FC<{
  每行个数: number;
}> = ({ 每行个数 = 10 }) => {
  return (
    <>
      {分割(干支排列表, 每行个数).map((单行) => (
        <tr>
          {单行.map((单列) => (
            <td>{单列}</td>
          ))}
        </tr>
      ))}
    </>
  );
};
```

| 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 甲子 | 乙丑 | 丙寅 | 丁卯 | 戊辰 | 己巳 | 庚午 | 辛未 | 壬申 | 癸酉 |
| 甲戌 | 乙亥 | 丙子 | 丁丑 | 戊寅 | 己卯 | 庚辰 | 辛巳 | 壬午 | 癸未 |
| 甲申 | 乙酉 | 丙戌 | 丁亥 | 戊子 | 己丑 | 庚寅 | 辛卯 | 壬辰 | 癸巳 |
| 甲午 | 乙未 | 丙申 | 丁酉 | 戊戌 | 己亥 | 庚子 | 辛丑 | 壬寅 | 癸卯 |
| 甲辰 | 乙巳 | 丙午 | 丁未 | 戊申 | 己酉 | 庚戌 | 辛亥 | 壬子 | 癸丑 |
| 甲寅 | 乙卯 | 丙辰 | 丁巳 | 戊午 | 己未 | 庚申 | 辛酉 | 壬戌 | 癸亥 |

当然也可以调整成 12 得到按地支对齐的排列

| 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 甲子 | 乙丑 | 丙寅 | 丁卯 | 戊辰 | 己巳 | 庚午 | 辛未 | 壬申 | 癸酉 | 甲戌 | 乙亥 |
| 丙子 | 丁丑 | 戊寅 | 己卯 | 庚辰 | 辛巳 | 壬午 | 癸未 | 甲申 | 乙酉 | 丙戌 | 丁亥 |
| 戊子 | 己丑 | 庚寅 | 辛卯 | 壬辰 | 癸巳 | 甲午 | 乙未 | 丙申 | 丁酉 | 戊戌 | 己亥 |
| 庚子 | 辛丑 | 壬寅 | 癸卯 | 甲辰 | 乙巳 | 丙午 | 丁未 | 戊申 | 己酉 | 庚戌 | 辛亥 |
| 壬子 | 癸丑 | 甲寅 | 乙卯 | 丙辰 | 丁巳 | 戊午 | 己未 | 庚申 | 辛酉 | 壬戌 | 癸亥 |

# 年干支

公元年的起点和干支循环的起点并没有对齐,所以要进行一下换算.

下方测试用例列出了始点的对应关系 有 3 年的偏移

```typescript
test("公元一年对应 汉平帝 元始元年 辛酉年", () => {
  expect(求公元年份干支(1)).toEqual("辛酉");
});

test("公元四年对应 汉平帝 元始四年 甲子年", () => {
  expect(求公元年份干支(4)).toEqual("甲子");
});

test("公元一八四年对应 汉灵帝 中平四年 甲子年", () => {
  expect(求公元年份干支(184)).toEqual("甲子");
});
```

可以很方便的写出转换公式

```typescript
/**
 *
 * @param 年偏移 任意整数
 * @param 基准年干支 公元1年为基准年 此年为辛酉年
 * @returns
 */
export const 求年干支 = (年偏移: number, 基准年干支: 干支 = "辛酉"): 干支 => {
  const 基准年偏移 = 干支排列表.indexOf(基准年干支);
  const 目标年偏移 = (年偏移 + 基准年偏移) % 60;
  return 干支排列表[目标年偏移];
};
```

# 月干支

一个月是公转 15 度,也就是说干支月是和星座完全对齐的

以春分作为岁首,也就是白羊座

月干支以`丙寅`作为起始点

```typescript
/**
 *
 * @param 月偏移 1-12月份序数分别对应 0-11的偏移
 * @param 年干
 * @returns
 */
export const 求月干支 = (月偏移: number, 年干: 天干): 干支 => {
  const 年干偏移 = 天干序数映射[年干] - 1;
  /** 以丙寅作为开始 */
  const 基准月偏移 = 干支排列表.indexOf("丙寅");
  const 目标月偏移 = (年干偏移 * 12 + 月偏移 + 基准月偏移) % 60;
  return 干支排列表[目标月偏移];
};
```

可以用五虎遁月歌作为单测
歌诀即是上方按地支 12 排列的第三列

```typescript
test("五虎遁月歌\n甲己之年丙作初，乙庚之岁戊为头。\n丙辛岁首从庚起，丁壬壬位顺流行。\n若问戊癸何方法，甲寅之上好推求。", () => {
  expect(求月干支(0, "甲")).toEqual("丙寅");
  expect(求月干支(0, "己")).toEqual("丙寅");

  expect(求月干支(0, "乙")).toEqual("戊寅");
  expect(求月干支(0, "庚")).toEqual("戊寅");

  expect(求月干支(0, "丙")).toEqual("庚寅");
  expect(求月干支(0, "辛")).toEqual("庚寅");

  expect(求月干支(0, "丁")).toEqual("壬寅");
  expect(求月干支(0, "壬")).toEqual("壬寅");

  expect(求月干支(0, "戊")).toEqual("甲寅");
  expect(求月干支(0, "癸")).toEqual("甲寅");
});
```

# 日干支

日干支只计算自传,每六十日一个周期.

1949 年 10 月 1 日`恰好`是`甲子`日.

```typescript
/**
 *
 * @param 日偏移 任意整数
 * @param 基准日干支 默认以甲子作为基准
 * @returns
 */
export const 求日干支 = (日偏移: number, 基准日干支: 干支 = "甲子"): 干支 => {
  const 基准日偏移 = 干支排列表.indexOf(基准日干支);
  const 目标日偏移 = (日偏移 + 基准日偏移) % 60;
  return 干支排列表[目标日偏移];
};
```

# 时干支

时干和月干保持一致

```typescript
/**
 * @param 时偏移 相对于前一日子时的偏移量 范围 0-23
 * @param 当日的日干
 */
export const 求时干支 = (时偏移: number, 日干: 天干): 干支 => {
  const 日干偏移 = 天干序数映射[日干] - 1;
  /** 以甲子作为开始 */
  const 基础时偏移 = 干支排列表.indexOf("甲子");
  const 目标时偏移 = (日干偏移 * 12 + 时偏移 + 基础时偏移) % 60;
  return 干支排列表[目标时偏移];
};
```

这里有一点需要注意的是

时支是时间段的概念,不是刻度概念.

所以目前对于`子`时分日是有争议的.

以时段视角来看,正`午`显然是`12:00`分

那么`午`时应该是`11:00`到`13:00`

这就导致每一天`子`时

是从前一天的`23:00`到当天的`1:00`来计算的

对称的用五鼠遁时歌诀来做单测

```typescript
test("五鼠遁日歌\n甲己还加甲，乙庚丙作初。\n丙辛从戊起，丁壬庚子居。\n戊癸何方发，壬子是真途。", () => {
  expect(求时干支(0, "甲")).toEqual("甲子");
  expect(求时干支(0, "己")).toEqual("甲子");

  expect(求时干支(0, "乙")).toEqual("丙子");
  expect(求时干支(0, "庚")).toEqual("丙子");

  expect(求时干支(0, "丙")).toEqual("戊子");
  expect(求时干支(0, "辛")).toEqual("戊子");

  expect(求时干支(0, "丁")).toEqual("庚子");
  expect(求时干支(0, "壬")).toEqual("庚子");

  expect(求时干支(0, "戊")).toEqual("壬子");
  expect(求时干支(0, "癸")).toEqual("壬子");
});
```

对应的是上方按地支 12 排列的第一列

# 节气

参考时辰的概念,`节气`对一年做了更加细致的划分.

用`节`和`气`交替排列,类似竹子一样对一年进行划分.

每一个`节`或者`气`对应 15 度的公转角

一个`节气`相和对应一个月,也可以对齐一个星座

其中

- `春分`和`秋分`对应太阳直射赤道
- `冬至`对应太阳直射南回归线
- `夏至`对应太阳直射北回归线

```typescript
enum 节 {
  立春 = "立春",
  惊蛰 = "惊蛰",
  清明 = "清明",
  立夏 = "立夏",
  芒种 = "芒种",
  小暑 = "小暑",
  立秋 = "立秋",
  白露 = "白露",
  寒露 = "寒露",
  立冬 = "立冬",
  大雪 = "大雪",
  小寒 = "小寒",
}

enum 气 {
  雨水 = "雨水",
  春分 = "春分",
  谷雨 = "谷雨",
  小满 = "小满",
  夏至 = "夏至",
  大暑 = "大暑",
  处暑 = "处暑",
  秋分 = "秋分",
  霜降 = "霜降",
  小雪 = "小雪",
  冬至 = "冬至",
  大寒 = "大寒",
}

export const 节气 = {
  ...节,
  ...气,
} as const;
```

因为公转不是自传的整数倍,所以需要天文测算落在哪一天.

自行拟合的话可以使用`VSOP87D`规范计算

这里偷懒直接拉香港天文台的数据

```typescript

const 请求 = async (url: string) => {
  const response = await axios.get(url)
  return response.data
}

const 地址 = (年份: number) => {
  // 香港天文台数据
  return `https://www.hko.gov.hk/tc/gts/time/calendar/text/files/T${年份}c.txt`
}

// 1901-2100
const 年份范围 = Array.from({ length: 2100 - 1901 + 1 }, (_, i) => 1901 + i)

await Promise.all(
  年份范围.map(async (年份) => {
    try {
      const 文件夹路径 = path.join(__dirname, 'HKO')
      const 文件路径 = path.join(文件夹路径, `${年份}.txt`)

      if (fs.existsSync(文件路径)) {
        console.log(`${年份}年数据已存在,跳过请求`)
      } else {
        console.log(`开始请求${年份}年数据`)
        const 数据 = await 请求(地址(年份))
        console.log(`${年份}年数据请求完成 正在写入${文件路径}`)
        fs.writeFileSync(文件路径, 数据)
      }
    } catch (error) {
      console.error(`获取${年份}年数据失败:`, error)
    }
  }),
)
```

# 四柱

知道了每一柱的算法,以及节气的划分 

就可以直接根据当前时间算出近200年的四柱

```typescript
export const 时间转八字 = (时间: dayjs.Dayjs) => {
  /**
   * 干支日以前一日的23点为子时起点
   */
  const 回溯时间 = 时间.add(1, 'hour')
  // 如果是1月1日的 则回溯到上一年
  const 公历年 = 回溯时间.year()

  const 当年节气数据 = (节气数据 as Record<number, T_节气数据[]>)[公历年]
  /** Js月是偏移,从0开始 */
  const 公历月 = 回溯时间.month()
  const 公历日 = 回溯时间.date()
  // 找到第一个月份相等的节气 若日期小于节气
  let 当前节气: T_节气数据
  let 节气在上一年 = false

  当年节气数据.some((每月节气数据, 索引) => {
    /** 节气公历月是序数 从1开始 */
    const { 公历月: 节气公历月, 公历日: 节气公历日 } = 每月节气数据
    if (节气公历月 === 公历月 + 1) {
      if (公历日 < 节气公历日) {
        const 前一个节气 = 当年节气数据[索引 - 1]

        //前一个节气在上一年
        if (!前一个节气) {
          const 上一年节气数据 = (节气数据 as Record<number, T_节气数据[]>)[公历年 - 1]
          当前节气 = { ...(上一年节气数据.at(-1) as T_节气数据) }
          节气在上一年 = true
        } else {
          当前节气 = { ...前一个节气 }
        }
        return true
      } else {
        当前节气 = 每月节气数据
      }
    }
  })

  const 立春节气 = 当年节气数据.find(({ 节气名 }) => 节气名 === 节气.立春) as T_节气数据

  /**
   * PS: 这里之前还有一个判断:
   * 当前节气.公历月 === 立春节气.公历月 && 当前节气.公历日 < 立春节气.公历日
   * 这种情况是不会出现的 立春在2月3日到2月5日 往前回溯一个节气的时点必然在1月
   */
  const 是否在立春之前 = 节气在上一年 || 当前节气.公历月 < 立春节气.公历月

  //干支年以春分为岁首   如果月/日在立春之前，则年份减一
  let 公历年序数 = 是否在立春之前 ? 公历年 - 1 : 公历年
  // 交节日为月首 按区间取对应的节气月
  let 月偏移 = 获取节气月偏移(当前节气.节气名)

  // 日偏移
  let 日偏移 = 回溯时间.diff(dayjs('1949-10-01'), 'day')
  //时偏移直接余2即可
  let 时偏移 = Math.floor(回溯时间.hour() / 2)

  const 年柱 = 求年干支(公历年序数 - 1)

  const 月柱 = 求月干支(月偏移, 年柱[0] as 天干)

  const 日柱 = 求日干支(日偏移)

  const 时柱 = 求时干支(时偏移, 日柱[0] as 天干)

  return {
    年柱,
    月柱,
    日柱,
    时柱,
    八字: `${年柱}-${月柱}-${日柱}-${时柱}`,
  }
}

```