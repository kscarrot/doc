# [Cursor](https://www.cursor.com/cn)

新号自带体验的额度,差不多只够用一天,体验不要钱,不刚需梯子

年度会员 16$/月,只支持外币卡,`Visa`可以,我试过 `PayPal` 是不可以的

下载后可以在右上角入口`Curosr Setting`处可以配置账号

下方提供了一键导入`vscode`配置的入口

全局配置和插件都能正常导入

布局的话多了右侧的 chat 窗口,除此之外区别不大

另外就是效果最好的模型`clade3.7-sonnet-max`是按次数收费的

使用过程的还是要预先充值一些费用

## 竞品分析

### [Tare](www.trae.com.cn)

和 `Cursor` 的设计思路一样的,也是魔改`vscode`

出活的话是没问题的,现在暂时不要钱,但是要排队

预制了一些方便的功能 交互设计的略微有些奇怪

快捷键不太一样

### [coplit](https://marketplace.visualstudio.com/items?itemName=GitHub.copilot)

最早体验上的 **ai**,引路人

基本上只有自动提示能用

`chat` 比较小丑,更不太敢用`composor`让他直接改代码

现在下载`vsocde`整个插件登录一下就能无缝集成了,应该是所有工具里最方便的

请求多了就不免费了,据说最近功能有改善

我的付费意愿不强烈,弃用了

### [Deepseek](https://chat.deepseek.com/)

上下文有限,通过`api`直调的话 反馈也是略有些奇怪

深度思考的部分比较好,在写`Fp`和`LaTex`方面明显比`Cursor`逻辑清晰一些

搓模板代码,和需要联网查的部分 可能是因为他为了通用没有专门对 Coding 生成足够多的索引 感觉是很慢,而且搜索的覆盖的范围比较小 很容易过拟合

目前看来比较适合外挂在半夜作为专门的`chat`使用

适合复杂逻辑的过程分析 帮助 review 代码

缺少界面的问题可以用开源库[aider](https://aider.chat/)去做请求发起

> Jetbrain 家的 **ai** 还有很大进步空间

# 基本功能

选中后

1. `Tab` 代码不全/自动提示光标移动
2. `command+K` 原地编辑
3. `command+L` 加入 Chat 然后编辑
4. `command+Y` 确定更改
5. `command+J` 移除更改

想要自动执行的话,开`agent`模式

然后设置里打开`enable auto run mode`

会提醒你可能存在的安全风险

能自动执行脚本那能安全的了嘛?

但是为了方便,也不用太在意

## 记忆

`HJKL`和`vim`的左下上右是对应的

- `K`向上 原地编辑 的浮窗就是出现在代码的上方的
- `L`向右 `chat`在右边

review 阶段

- `Y` accept 更改
- `J` reject 更改

以前是`CV`工程师

现在`CV`都自动化了,只需要点头`Y`摇头`J`就好了

苹果给的[听写功能](https://support.apple.com/zh-cn/guide/mac-help/mh40584/mac)可以和 `chats` 无缝配合起来

就是稍微有点尴尬,需要在工位上自言自语

# 上下文

在交互弹窗里输入`@`可以增加变更的上下文

编辑时常用的是`@file`和`@code` 增加指定的文件和指定的代码段

修复时常用`@lint error`和`@terminal`

让 **ai** 可以直接介入出错的位置进行分析

比如执行单测报错,或者安装某个包依赖冲突报错,或者命令执行权限不够报错,可以选中终端的命令行输出内容,让 **ai** 分析原因,给出解决方案再继续向下执行

在原地编辑的时候可能会用`@chat`去补充之前聊天交互的上下文

类似`.gitignore`,也可以通过配置`.curosrignore`去排除仓库/二进制文件,屏蔽无需介入的文件提高索引效率

# 规则

规则可以理解为调用 **ai** 时候传的额外的配置参数

在`Curosr Settings`的`Rules`面板配置

比如第一次打开就可以在`User Rules`配上

```markdown
Always respond in 中文
```

这样后续的回答,**ai** 都会用中文回答你,而不是直接输出英文字句

## 通用规则

### 1. 代码提交规范

可以比较好的替代`commitizen`

这个根据组内的规范来就好,沿用之前的配置即可

大体上是

- `feat`
- `fix`
- `refactor`
- `chore`
- `perf`
- `text`
- `ci`
- `text`
- `style`

其中`feat`,`fix`,`perf`配了单独的模板,可以让 **ai** 自动总结变更内容作为提交信息

提交的时候让 **ai** 执行 `rebase` 操作避免 **ai** 时代频繁 `commit` 带来的困扰

### 2. 项目规范

一般是目录结构

重点可以强调一下`README.md`,然后是接口协议`proto`

不要担心协议过多会给 **ai** 造成幻觉

`lint`和`format`不要让 **ai** 直接做,用专门的工具搞比较好

**ai** 更适合提交的时候配钩子去执行工具 做好监督的角色

## 项目规则

### 1. 技术方案

可以把需求级别的技术方案作为`rules`绑定

这样 **ai** 能比较好的理解中间过程的意图

会试图根据流程图和时序图上标准来处理调用链

并且命名上也会有很好的一致性

这里可以显式的写出领域相关词汇,要求 **ai** 生成出友好可读的注释

### 2. 引用库的文档

这里一般是框架或者集成 SDK 的`README.md`

会有示例代码,保证会按照库的最佳实践去写

### 3. 领域知识

这里可以直接把产品文档汇集起来让 **ai** 总结一份

包括`术语词汇表`,`业务流程`,`业务分块`

### 4. 需求单

需求单是迭代的,放专门的文件夹进行归档

开发单个需求的时候可以截取部分信息作为规则让 **ai** 去了解背景

- 需求改动点
- 功能改动点
- 多语言文案对照
- 对接的接口服务方

需求提交完以后从规则里移出然后归档即可

# 我的标准流程

让 **ai** 执行的时候,步骤尽可能清晰而短,拆多个`git commit`

审阅完一个改动直接`git add`,避免叠加改动的时候产生干涉

复杂需求不能一次性生成的话可以先生成最小实现

## 不熟悉业务的前置步骤

### 0. 调用图

可以写个**ast**分析的脚本让 **ai** 总结调用关系,然后绘制流程图 这种调用都有现成的

然后根据自己需要了解的代码生成对应的代码功能开发文档



### 1. 定位

定位到需要修改的代码,加入上下文

比如我知道`api path` 可以让 **ai** 帮助定位到对应的服务

`command+p`从文件的维度去追踪变化

定位到文件后可以`command+p+@`在`label`的维度去追踪

然后使用行号框选`<起始行>:<结束行>`对应代码段

如果其他地方有类似的改动,也可以加入上下文让 **ai** 预先进行学习和模仿

### 2. 执行

如果是简单函数,修改类型和函数注释,直接`command+K`
原地改代码就行

如果是比较复杂的,可以`command+L`可以把选择的部分加入到`chat`的上下文

然后继续定位关联的模块

最后在`chat`里调用`agent`去完成修改

代码定位的信息足够精确可以显著减少 **ai** 的幻觉

执行完之后可以要求 **ai** 对他这次的变动做一个总结

### 3. 提交

如果是有单测的,可以让 **ai** 帮助补充新逻辑的单测

可以让 **ai** 去 diff 单测报告 做好分支覆盖

然后执行单测

接着是自己审查 **ai** 提交的的改动点

这一步必不可少,**ai** 抽风很难避免

包括但不限于

- 新增/修改枚举常量
- 写特殊逻辑 绕过检查机制乱
- 引用奇怪的代码
- 修改无关的逻辑
- 诡异的重命名等

提交的时候还是需要逐个改动点`accept`,尽量不要不看就全盘接受

# 跨仓读取

如果项目 A 改了某个通用功能要移植到 B 项目比应该如何操作

可以直接列出代码变动喂给 **ai**
首先再 A 仓库绑定 B 仓库,并拉取对应代码

```bash
# https://git-scm.com/docs/git-remote
get remote add <project-name> <source path>
get fetch <project-name>
```

`git log`找到需要让 **ai** 读取的`commit hash`

```bash
git show <commit hash>
# 列出改动的文件路径 可以写到一个md文件里
# 然后让ai预先读取commit里每个文件的变化 就能知道B仓库的某个提交做了什么
git show <commit hash> <file-path>
```

接着让 **ai** 总结 B 仓库 commit 的改动

基于当前项目,进行分析和执行就可以
